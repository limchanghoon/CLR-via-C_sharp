# 1장.CLR의 실행 모델

**CLR** (Common Language Runtime, 공용 언어 모델) : 서로 다른 프로그래밍 언어들 사이에서 공동으로 사용할 수 있는 실행 환경(Runtime)

**메타 데이터** : 모듈 내의 타입과 그들의 구성 멤버와 같은 정보들의 데이터 테이블의 집합, 외부에서 참조하는 모듈에 관한 정보 포함

`소스 파일` -in-> `해당 언어 컴파일러` -out-> `IL(Intermediate Language,중간 언어)`,`메타 데이터`

**중간 언어(IL)**를 이용해 **CPU**와 **OS**에 독립적인 **기계어 코드**를 작성!

`여러 관리 모듈(IL과 메타 데이터) + 리소스 파일` -in-> `컴파일러, 어셈블리 링커, ...` -out->  `어셈블리`



## CLR 로딩

윈도우가 EXE 파일 헤더에 들어있는 정보에 따라 32비트 또는 64비트 프로세스를 결정해, 윈도우는 MSCorEE.dll의 x86, x64 혹은 ARM 버전을 그 프로세스의 주소 공간에 로딩한다. 그 후, 프로세스의 주 스레드가 MSCorEE.dll 안에 정의된 메소드를 호출한다. 이 메소드는 CLR을 초기화하고 EXE 어셈블리를 블러들이고, Main 함수를 호출한다. 이 시점에서 관리 애플리케이션이 실행된다.



## 어셈블리 코드 실행

메소드를 실행하기 위하여, 그 메소드의 IL은 네이티브 CPU 명령어로 변환된다. 이 작업은 CLR의 **JIT(Just-in-time)** 컴파일러에 의하여 실행된다. 성능 저하는 메서드가 최초로 호출될 때에만 발생한다. 그 메소드에 대한 이어지는 모든 호출들은 네이티브 코드 수행과 같은 속도로 실행되는데,이는  네이티브 코드에 대한 검증과 컴파일이 다시 수행될 필요가 없기 때문이다.

코드 최적화에 영향을 미치는 2개의 C# 컴파일러 스위치가 있다: /optimize와 /debug. 

| 컴파일러 스위치 설정                | C# IL 코드 품질 | JIT 네이티브 코드 품질 |
| ----------------------------------- | --------------- | ---------------------- |
| /optimize- /debug- (기본)           | 최적화 안함     | 최적화 함              |
| /optimize- /debug(+/full/pdbonly)   | 최적화 안함     | 최적화 안함            |
| /optimize+ /debug(-/+/full/pdbonly) | 최적화 함       | 최적화 함              |



## IL과 검증

**IL**은 스택 기반의 언어이며, 명령이 타입 종류에 무관하다.

**IL**을 **네이티브 CPU 명령어**로 컴파일하는 동안, **CLR**은 **안정성 확인 과정**을 거치게 한다.

윈도우에서 각 프로세스는 **고유의 가상 주소 공간**을 가진다. 관리 코드를 검증함으로써, 그 코드가 부적절하게 메모리를 접근하지 않고, 다른 애플리케이션의 코드를 악의적으로 침범하지 않음을 알 수 있다. 이는 여러분은 단일 윈도우 가상 주소 공간에서 여러개의 관리 애플리케이션을 동작시킬 수 있음을 의미한다.



## 안전하지 않은 코드

기본적으로 C# 컴파일러는 안전한 코드를 만든다. 하지만 unsafe 키워드를 추가하면 안전하지 않은 코드(메모리 주소를직접 제어하는 코드)를 사용할 수 있다. 또한 컴파일시, /unsafe 스위치를 사용해야한다.



## 네이티브 코드 생성 도구 : NGEN.EXE

.NET Framework와 함께 제공되는 도구이다. **IL** 코드를 **네이티브** 코드로 컴파일하는 데 사용된다. 응용프로그램이 사용자의 컴퓨터에 설치되는 경우 사용됨. 즉, 설치 시점에서 컴파일된다. 결과적으로, 런타임에 컴파일이 발생하지 않기 때문에 실행 속도가 개선된다.



## 프레임워크 클래스 라이브러리 : (Framework Class Library, FCL)

DLL 어셈블리들의 집합, 이 집합은 다양한 기능들을 제공하는 수천 가지 이상의 타입들로 구성된다.



## 공용 타입 시스템 : (Common Type System, CTS)

타입이란 한 프로그래밍 언어로 작성된 코드가 다른 프로그래밍 언어로 작성된 코드들과 소통하는 메커니즘. 마이크로소프트 CLR에서의 표준이 **CTS**이다.

CTS 명세는 타입은 다음과 같은 멤버를 0개 이상 포함할 수 있음을 명시한다.

- **Field**
- **Method**
- **Property**
- **Event**

CTS는 또한 타입의 가시성과 타입의 멤버의 접근성을 제어할 수 있다.

- **Private** : 이 멤버는 같은 클래스 타입 내의 다른 멤버에 의해서만 접근이 가능.
- **Family** : 이 멤버는 파생된 타입에서 접근될 수 있는데, 같은 어셈블리에 없어도 상관없다. C#에서는 protected로 언급된다.
- **Family and assembly** : 이 멤버는 파생된 타입에서 접근될 수 있는데, 오직 같은 어셈블리 내에서 정의된 타입이어야 한다. C#에서는 지원하지 않고, 오직 IL 어셈블리 언어에서만 사용 가능하다.
- **Assembly** : 이 멤버는 같은 어셈블리 내의 모든 코드에서 접근될 수 있다. C#에서는 internal로 언급된다.
- **Family or assembly** : 이 멤버는 모든 어셈블리 내의 파생된 타입에서 접근될 수 있고, 또한 같은 어셈블리 내의 모든 타입에서도 접근될 수 있다. C#은 이를 protected internal로 언급한다.
- **Public** : 이 멤버는 모든 어셈블리의 모든 코드에서 접근 가능하다.

또 다른 CTS 규칙은 모든 타입들은 사전에 정의된 타입인 `System.Object`를 상속 받아야 한다는 것이다. 그래서 모든 타입의 인스턴스는 다음과 같은 최소한의 행동 집합을 가짐을 보장한다.

- 두개의 인스턴스를 동등 비교한다.
- 인스턴스에 대한 해시 코드를 구한다.
- 한 인스턴스의 진짜 타입을 질의한다.
- 인스턴스의 앝은 복사(비트 단위의 복사)를 수행한다.
- 인스턴스의 현재 상태를 표현하는 문자열을 얻는다.

## 공용 언어 사양(Common Language Specification)

특정 언어에서만 제공하는 기능은 Public이나 Protected 멤버에서는 사용할 수 없다.