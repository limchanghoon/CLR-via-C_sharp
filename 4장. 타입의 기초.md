# 4장. 타입의 기초

모든 타입은 `System.Object`타입으로 부터 파생된다. (모든 타입의 최상위 클래스)

**new** 연산자 : 모든 인스턴스 필드들을 메모리에 할당하기 위한 바이트 수 + **타입 객체 포인터** + **동기화 블록 인덱스** 크기를 계산해 메모리를 할당한다. 인스턴스의 생성자가 실행되고 만들어진 객체의 참조(또는 포인터)가 반환된다.



## 타입 간 캐스팅

CLR은 객체의 현재 타입에 근접한 타입 또는 기본 타입으로 캐스팅을 지원한다. C#의 경우 **기본 타입으로**의 형 변환은 **암묵적**으로 가능하나, **파생 타입으로**의 형 변환은 **명시적** 캐스팅을 해줘야한다. 이는 실행시 코드가 실패할 수 있기 때문이다.



## C#의 is와 as 연산자로 캐스팅하기

**is** : is를 중심으로 좌변과 우변의 형식이 같으면 true를 반환하고 다르면 false를 반환한다.

**as** : as를 중심으로 좌변의 객체를 우변의 형식으로 캐스팅한다. 캐스팅할 수 없는 경우 null을 반환한다.



## 네임스페이스와 어셈블리

**네임스페이스** : 서로 관련이 있는 타입들을 논리적으로 그룹화하기 위한 수단 (System.IO 등). 보통 **using** 지시자를 이용해 사용한다. 또한 using 사용시 다음의 예시처럼 별칭으로 선언할 수도 있다.`using WintellectWidget = Wintellect.Widget`. 만약 네임스페이스가 같고 그 내부의 형식도 같은 타입이 존재한다면 **extern 별칭(extern alias)**를 사용해야한다.

#### extern 별칭(extern alias)

정규화된 형식 이름이 동일한 두 어셈블리를 참조하려면 다음과 같이 명령 프롬프트에서 별칭을 지정해야 합니다.

```c#
/r:GridV1=grid.dll
/r:GridV2=grid20.dll
```

(Visual Studio 사용시 다음과 같은 방법으로 위와 같은 처리를 대체가능하다.  Visual Studio의 프로젝트에 *grid.dll* 및 *grid20.dll* 의 참조를 추가합니다. 속성 탭을 열고 별칭을 전역에서 GridV1 및 GridV2로 각각 변경합니다.)

그러면 외부 별칭 `GridV1` 및 `GridV2`가 생성됩니다. 프로그램 내에서 이러한 별칭을 사용하려면 `extern` 키워드를 사용하여 참조합니다. 예들 들어 다음과 같습니다.

```c#
extern alias GridV1;  

extern alias GridV2;

using Class1V1 = GridV1::Namespace.Class1;

using Class1V2 = GridV2::Namespace.Class1;
```



## 실행 시점과의 연관성

다음은 범용적인 이론이다.

새로운 스레드를 만들 때에는 스레드당 1MB 크기의 스택이 할당된다. 이 스택 공간은 메서드로 인수를 전달하는 과정에서 사용하거나 메서드 내에서 사용하는 지역변수를 보관하기 위하여 사용된다. 메서드 실행시 보통 다음과 같은 순서로 스레드 스택에 쌓인다.

**메서드 실행 ->  [매개변수] 를 할당-> [return address] 을 할당-> [지역변수]를 할당**

### CLR에서의 실행

프로세스 실행시 메소드들의 IL코드를 CPU명령어로 변환시키면서, 메소드 안에서 참조하는 **타입(객체)**들에 대한 정보의 자료 구조를 **관리되는 힙**에 만든다. 이 자료 구조에는 타입 정보 말고도 **타입 객체 포인터**와 **동기화 블록 인덱스**가 포함된다. 그리고 타입 선언할 때 정적 데이터 필드를 포함 시킬 수도 있다.(정적 데이터 필드의 할당 메모리는 타입 객체를 만드는 시점에서 할당됨) 이렇게 컴파일이 완료되고 메서드가 실행되면, 위의 일반적 과정과 같이 스레드 스택에 쌓인다. 이때 지역변수 명시된 초기값이나 null또는 0으로 초기화된다. 그뒤 객체 생성 코드를 만나면 **힙에 객체를 생성**하고 이 객체의 타입 객체 포인터는 **타입에 부한하는 타입 객체**에 연결된다. 또한 객체의 메소드가 최초 실행되면 IL코드를 CPU명령어로 컴파일한다.

