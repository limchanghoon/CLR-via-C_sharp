# 6장. 타입과 멤버의 기본

## 이웃 어셈블리

**internal 멤버와 타입**을 다른 어셈블리에서 접근하게 허용하려면 다음의 코드를 넣어야한다.

```c#
using System.Runtime.CompilerServices;
[assembly:InternalsVisbleTo("어셈블리명, 공개 키 값")]
```

접근을 요청하는 어셈블리를 컴파일할 때는 /out:<file> 컴파일러 스위치를 이용해 파일이름을 특정해줘야한다. 또한 이웃 어셈블리에 속하는 모듈을 컴파일할 때는 /moduleassemblyname:<string> 스위치를 이용해 어떤 어셈블리의 일부인지 특정해줘야한다.

이러한 기능을 **이웃 어셈블리(Friend Assembly)**라고 한다.



## 멤버 접근성

C#에서는 선언하는 멤버에 명시적으로 한정자를 지정하지 않는 경우, 대개 private를 자동으로 선태하여 적용한다. 또한 인터페이스에는 명시적으로 한정자를 지정할 수 없고, 자동으로 컴파일러가 public을 지정해준다.

상속받는 타입에서 기본 타입의 멤버를 재정의하는 경우 C#에선 기본 타입의 멤버 접근성을 그대로 가져온다. CLR에선 상속받는 타입에서 접근성을 확장시킬 수도 있다.



## 정적 클래스

**정적 클래스**란 인스턴스로 생성되지 않도록 보호되는 관련성 있는 메서드들의 집합으로 표현되는 클래스이다. **static 키워드**를 사용해 클래스를 선언한다.

- 정적 클래스는 반드시 System.Object에서만 상속을 받도록 제한한다.
- 정적 클래스는 인터페이스를 구현할 수 없다. 인터페이스 메서드는 반드시 클래스의 인스턴스로 생성될 때에만 호출할 수 있기 때문이다.
- 정적 클래스 안에서는 필드, 메서드, 속성, 이벤트는 모두 정적 멤머볼 선언되어야만 한다.

정적 클래스를 선언해 컴파일하면, C# 컴파일러는 정적 클래스에 자동으로 abstract와 sealed 특성을 지정한다. 당연하게도 인스턴스 생성자는 자동생성되지 않는다.



## 부분 클래스, 부분 구조체, 부분 인터페이스

**partial 키워드**를 이용하면 한 소스 코드 파일 내에서 여러 조각으로 타입의 선언을 분할하거나 여러 소스 코드 파일에 걸쳐 여러 조각으로 타입의 선언을 분할할 수 있게 된다.



## 컴포넌트, 다형성, 버전관리

**컴포넌트 소프트웨어 프로그램밍**, 즉 다양한 회사에서 만든 어셈블리들이 모여 구성되는 것을 말한다.

또한 이런 컴포넌트(어셈블리에 정의된 클래스 등)의 다형성과 버전 관리를 위해 다음같은 키워드들이 존재한다.

- **abstract** : 이것이 적용된 타입은 인스턴스로 만들 수 없다. 이것이 적용된 멤버가 있는 타입을 상속받은 타입은 abstract 멤버를 반드시 구현(재정의)해야한다.
- **virtual** : 타입에는 적용 불가. 이것이 적용된 멤버가 있는 타입을 상속받은 타입은 virtual 멤버를 재정의할 수 있다.
- **override** : 타입에는 적용 불가. 기본 타입의 가상 멤버를 재정의한다.
- **sealed** : 이것이 적용된 타입은 다른 타입의 기본 타입이 될 수 없다. 이것이 적용된 멤버는 상속 이후에 재정의할 수 없다. 이 키워드는 가상 메서드를 재정의하는 메서드에 대해서만 지정할 수 있다.



### 속성이란?

C#에서 속성 : Get함수와 Set함수가 포함된 하나의 변수라고 할 수 있다.

```c#
public int X
{
    get		// get 함수 역할
    {
        return x;
    }
    set		// set 함수 역할
    {
        if (0 <= value)
            x = value;
    }
}
X = -5; 	// set 실행
int Y = X;	// get 실행
```



## 타입의 가시성과 멤버의 접근성을 지능적으로 활용하는 방법

- 기본적으로 클래스를 만들 때 **sealed 키워드**를 명시적으로 설정해주는 것이 좋다. 클래스를 봉인시킴으로써 **불필요한 상속**을 막을 수 있어 관리와 보안에 좋고, 가상 메서드의 호출을 비가상 메서드로 호출해 성능을 향상시킬 수 있다.

- 클래스 안에서는 항상 데이터 필드를 private 멤버로 선언하라. 객체의 상태를 외부를 노출시키면 예측불가한 잠재적 보안 취약점을 만들기도 한다.

- 복잡해지면 중첩 타입을 고려하라. 

